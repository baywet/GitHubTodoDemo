/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { type AdditionalDataHolder, type DateOnly, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface AttachmentBase extends Entity, Parsable {
    /**
     * The MIME type.
     */
    contentType?: string | null;
    /**
     * The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * The display name of the attachment. This doesn't need to be the actual file name.
     */
    name?: string | null;
    /**
     * The length of the attachment in bytes.
     */
    size?: number | null;
}
export interface AttachmentSession extends Entity, Parsable {
    /**
     * The content streams that are uploaded.
     */
    content?: String | null;
    /**
     * The date and time in UTC when the upload session will expire. The complete file must be uploaded before this expiration time is reached.
     */
    expirationDateTime?: Date | null;
    /**
     * Indicates a single value {start} that represents the location in the file where the next upload should begin.
     */
    nextExpectedRanges?: string[] | null;
}
export interface BaseCollectionPaginationCountResponse extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataCount property
     */
    odataCount?: number | null;
    /**
     * The OdataNextLink property
     */
    odataNextLink?: string | null;
}
export type BodyType = (typeof BodyTypeObject)[keyof typeof BodyTypeObject];
export interface ChecklistItem extends Entity, Parsable {
    /**
     * The date and time when the checklistItem was finished.
     */
    checkedDateTime?: Date | null;
    /**
     * The date and time when the checklistItem was created.
     */
    createdDateTime?: Date | null;
    /**
     * Indicates the title of the checklistItem.
     */
    displayName?: string | null;
    /**
     * State that indicates whether the item is checked off or not.
     */
    isChecked?: boolean | null;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AttachmentBase}
 */
// @ts-ignore
export function createAttachmentBaseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.taskFileAttachment":
                    return deserializeIntoTaskFileAttachment;
            }
        }
    }
    return deserializeIntoAttachmentBase;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AttachmentSession}
 */
// @ts-ignore
export function createAttachmentSessionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAttachmentSession;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BaseCollectionPaginationCountResponse}
 */
// @ts-ignore
export function createBaseCollectionPaginationCountResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBaseCollectionPaginationCountResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChecklistItem}
 */
// @ts-ignore
export function createChecklistItemFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChecklistItem;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DateTimeTimeZone}
 */
// @ts-ignore
export function createDateTimeTimeZoneFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDateTimeTimeZone;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Entity}
 */
// @ts-ignore
export function createEntityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.attachmentBase":
                    return deserializeIntoAttachmentBase;
                case "#microsoft.graph.attachmentSession":
                    return deserializeIntoAttachmentSession;
                case "#microsoft.graph.checklistItem":
                    return deserializeIntoChecklistItem;
                case "#microsoft.graph.extension":
                    return deserializeIntoExtension;
                case "#microsoft.graph.linkedResource":
                    return deserializeIntoLinkedResource;
                case "#microsoft.graph.openTypeExtension":
                    return deserializeIntoOpenTypeExtension;
                case "#microsoft.graph.taskFileAttachment":
                    return deserializeIntoTaskFileAttachment;
                case "#microsoft.graph.todoTask":
                    return deserializeIntoTodoTask;
                case "#microsoft.graph.todoTaskList":
                    return deserializeIntoTodoTaskList;
            }
        }
    }
    return deserializeIntoEntity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Extension}
 */
// @ts-ignore
export function createExtensionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode?.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.openTypeExtension":
                    return deserializeIntoOpenTypeExtension;
            }
        }
    }
    return deserializeIntoExtension;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ItemBody}
 */
// @ts-ignore
export function createItemBodyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoItemBody;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {LinkedResource}
 */
// @ts-ignore
export function createLinkedResourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoLinkedResource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OpenTypeExtension}
 */
// @ts-ignore
export function createOpenTypeExtensionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOpenTypeExtension;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PatternedRecurrence}
 */
// @ts-ignore
export function createPatternedRecurrenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPatternedRecurrence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RecurrencePattern}
 */
// @ts-ignore
export function createRecurrencePatternFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRecurrencePattern;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RecurrenceRange}
 */
// @ts-ignore
export function createRecurrenceRangeFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRecurrenceRange;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TaskFileAttachment}
 */
// @ts-ignore
export function createTaskFileAttachmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTaskFileAttachment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TodoTaskCollectionResponse}
 */
// @ts-ignore
export function createTodoTaskCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTodoTaskCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TodoTask}
 */
// @ts-ignore
export function createTodoTaskFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTodoTask;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TodoTaskListCollectionResponse}
 */
// @ts-ignore
export function createTodoTaskListCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTodoTaskListCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TodoTaskList}
 */
// @ts-ignore
export function createTodoTaskListFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTodoTaskList;
}
export interface DateTimeTimeZone extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * A single point of time in a combined date and time representation ({date}T{time}; for example, 2017-08-29T04:00:00.0000000).
     */
    dateTime?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Represents a time zone, for example, 'Pacific Standard Time'. See below for more possible values.
     */
    timeZone?: string | null;
}
export type DayOfWeek = (typeof DayOfWeekObject)[keyof typeof DayOfWeekObject];
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAttachmentBase(attachmentBase: Partial<AttachmentBase> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(attachmentBase),
        "contentType": n => { attachmentBase.contentType = n.getStringValue(); },
        "lastModifiedDateTime": n => { attachmentBase.lastModifiedDateTime = n.getDateValue(); },
        "name": n => { attachmentBase.name = n.getStringValue(); },
        "size": n => { attachmentBase.size = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAttachmentSession(attachmentSession: Partial<AttachmentSession> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(attachmentSession),
        "content": n => { attachmentSession.content = n.getStringValue(); },
        "expirationDateTime": n => { attachmentSession.expirationDateTime = n.getDateValue(); },
        "nextExpectedRanges": n => { attachmentSession.nextExpectedRanges = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoBaseCollectionPaginationCountResponse(baseCollectionPaginationCountResponse: Partial<BaseCollectionPaginationCountResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.count": n => { baseCollectionPaginationCountResponse.odataCount = n.getNumberValue(); },
        "@odata.nextLink": n => { baseCollectionPaginationCountResponse.odataNextLink = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoChecklistItem(checklistItem: Partial<ChecklistItem> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(checklistItem),
        "checkedDateTime": n => { checklistItem.checkedDateTime = n.getDateValue(); },
        "createdDateTime": n => { checklistItem.createdDateTime = n.getDateValue(); },
        "displayName": n => { checklistItem.displayName = n.getStringValue(); },
        "isChecked": n => { checklistItem.isChecked = n.getBooleanValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDateTimeTimeZone(dateTimeTimeZone: Partial<DateTimeTimeZone> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "dateTime": n => { dateTimeTimeZone.dateTime = n.getStringValue(); },
        "@odata.type": n => { dateTimeTimeZone.odataType = n.getStringValue(); },
        "timeZone": n => { dateTimeTimeZone.timeZone = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoEntity(entity: Partial<Entity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "id": n => { entity.id = n.getStringValue(); },
        "@odata.type": n => { entity.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoExtension(extension: Partial<Extension> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(extension),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoItemBody(itemBody: Partial<ItemBody> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "content": n => { itemBody.content = n.getStringValue(); },
        "contentType": n => { itemBody.contentType = n.getEnumValue<BodyType>(BodyTypeObject); },
        "@odata.type": n => { itemBody.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoLinkedResource(linkedResource: Partial<LinkedResource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(linkedResource),
        "applicationName": n => { linkedResource.applicationName = n.getStringValue(); },
        "displayName": n => { linkedResource.displayName = n.getStringValue(); },
        "externalId": n => { linkedResource.externalId = n.getStringValue(); },
        "webUrl": n => { linkedResource.webUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoOpenTypeExtension(openTypeExtension: Partial<OpenTypeExtension> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoExtension(openTypeExtension),
        "extensionName": n => { openTypeExtension.extensionName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoPatternedRecurrence(patternedRecurrence: Partial<PatternedRecurrence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.type": n => { patternedRecurrence.odataType = n.getStringValue(); },
        "pattern": n => { patternedRecurrence.pattern = n.getObjectValue<RecurrencePattern>(createRecurrencePatternFromDiscriminatorValue); },
        "range": n => { patternedRecurrence.range = n.getObjectValue<RecurrenceRange>(createRecurrenceRangeFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRecurrencePattern(recurrencePattern: Partial<RecurrencePattern> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "dayOfMonth": n => { recurrencePattern.dayOfMonth = n.getNumberValue(); },
        "daysOfWeek": n => { recurrencePattern.daysOfWeek = n.getCollectionOfEnumValues<DayOfWeek>(DayOfWeekObject); },
        "firstDayOfWeek": n => { recurrencePattern.firstDayOfWeek = n.getEnumValue<DayOfWeek>(DayOfWeekObject); },
        "index": n => { recurrencePattern.index = n.getEnumValue<WeekIndex>(WeekIndexObject); },
        "interval": n => { recurrencePattern.interval = n.getNumberValue(); },
        "month": n => { recurrencePattern.month = n.getNumberValue(); },
        "@odata.type": n => { recurrencePattern.odataType = n.getStringValue(); },
        "type": n => { recurrencePattern.type = n.getEnumValue<RecurrencePatternType>(RecurrencePatternTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRecurrenceRange(recurrenceRange: Partial<RecurrenceRange> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "endDate": n => { recurrenceRange.endDate = n.getDateOnlyValue(); },
        "numberOfOccurrences": n => { recurrenceRange.numberOfOccurrences = n.getNumberValue(); },
        "@odata.type": n => { recurrenceRange.odataType = n.getStringValue(); },
        "recurrenceTimeZone": n => { recurrenceRange.recurrenceTimeZone = n.getStringValue(); },
        "startDate": n => { recurrenceRange.startDate = n.getDateOnlyValue(); },
        "type": n => { recurrenceRange.type = n.getEnumValue<RecurrenceRangeType>(RecurrenceRangeTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTaskFileAttachment(taskFileAttachment: Partial<TaskFileAttachment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAttachmentBase(taskFileAttachment),
        "contentBytes": n => { taskFileAttachment.contentBytes = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTodoTask(todoTask: Partial<TodoTask> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(todoTask),
        "attachments": n => { todoTask.attachments = n.getCollectionOfObjectValues<AttachmentBase>(createAttachmentBaseFromDiscriminatorValue); },
        "attachmentSessions": n => { todoTask.attachmentSessions = n.getCollectionOfObjectValues<AttachmentSession>(createAttachmentSessionFromDiscriminatorValue); },
        "body": n => { todoTask.body = n.getObjectValue<ItemBody>(createItemBodyFromDiscriminatorValue); },
        "bodyLastModifiedDateTime": n => { todoTask.bodyLastModifiedDateTime = n.getDateValue(); },
        "categories": n => { todoTask.categories = n.getCollectionOfPrimitiveValues<string>(); },
        "checklistItems": n => { todoTask.checklistItems = n.getCollectionOfObjectValues<ChecklistItem>(createChecklistItemFromDiscriminatorValue); },
        "completedDateTime": n => { todoTask.completedDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "createdDateTime": n => { todoTask.createdDateTime = n.getDateValue(); },
        "dueDateTime": n => { todoTask.dueDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "extensions": n => { todoTask.extensions = n.getCollectionOfObjectValues<Extension>(createExtensionFromDiscriminatorValue); },
        "hasAttachments": n => { todoTask.hasAttachments = n.getBooleanValue(); },
        "importance": n => { todoTask.importance = n.getEnumValue<Importance>(ImportanceObject); },
        "isReminderOn": n => { todoTask.isReminderOn = n.getBooleanValue(); },
        "lastModifiedDateTime": n => { todoTask.lastModifiedDateTime = n.getDateValue(); },
        "linkedResources": n => { todoTask.linkedResources = n.getCollectionOfObjectValues<LinkedResource>(createLinkedResourceFromDiscriminatorValue); },
        "recurrence": n => { todoTask.recurrence = n.getObjectValue<PatternedRecurrence>(createPatternedRecurrenceFromDiscriminatorValue); },
        "reminderDateTime": n => { todoTask.reminderDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "startDateTime": n => { todoTask.startDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "status": n => { todoTask.status = n.getEnumValue<TaskStatus>(TaskStatusObject); },
        "title": n => { todoTask.title = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTodoTaskCollectionResponse(todoTaskCollectionResponse: Partial<TodoTaskCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(todoTaskCollectionResponse),
        "value": n => { todoTaskCollectionResponse.value = n.getCollectionOfObjectValues<TodoTask>(createTodoTaskFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTodoTaskList(todoTaskList: Partial<TodoTaskList> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(todoTaskList),
        "displayName": n => { todoTaskList.displayName = n.getStringValue(); },
        "extensions": n => { todoTaskList.extensions = n.getCollectionOfObjectValues<Extension>(createExtensionFromDiscriminatorValue); },
        "isOwner": n => { todoTaskList.isOwner = n.getBooleanValue(); },
        "isShared": n => { todoTaskList.isShared = n.getBooleanValue(); },
        "tasks": n => { todoTaskList.tasks = n.getCollectionOfObjectValues<TodoTask>(createTodoTaskFromDiscriminatorValue); },
        "wellknownListName": n => { todoTaskList.wellknownListName = n.getEnumValue<WellknownListName>(WellknownListNameObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTodoTaskListCollectionResponse(todoTaskListCollectionResponse: Partial<TodoTaskListCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(todoTaskListCollectionResponse),
        "value": n => { todoTaskListCollectionResponse.value = n.getCollectionOfObjectValues<TodoTaskList>(createTodoTaskListFromDiscriminatorValue); },
    }
}
export interface Entity extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The unique identifier for an entity. Read-only.
     */
    id?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface Extension extends Entity, Parsable {
}
export type Importance = (typeof ImportanceObject)[keyof typeof ImportanceObject];
export interface ItemBody extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The content of the item.
     */
    content?: string | null;
    /**
     * The type of the content. Possible values are text and html.
     */
    contentType?: BodyType | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface LinkedResource extends Entity, Parsable {
    /**
     * The app name of the source that sends the linkedResource.
     */
    applicationName?: string | null;
    /**
     * The title of the linkedResource.
     */
    displayName?: string | null;
    /**
     * ID of the object that is associated with this task on the third-party/partner system.
     */
    externalId?: string | null;
    /**
     * Deep link to the linkedResource.
     */
    webUrl?: string | null;
}
export interface OpenTypeExtension extends Extension, Parsable {
    /**
     * A unique text identifier for an open type data extension. Optional.
     */
    extensionName?: string | null;
}
export interface PatternedRecurrence extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The frequency of an event.  For access reviews: Do not specify this property for a one-time access review.  Only interval, dayOfMonth, and type (weekly, absoluteMonthly) properties of recurrencePattern are supported.
     */
    pattern?: RecurrencePattern | null;
    /**
     * The duration of an event.
     */
    range?: RecurrenceRange | null;
}
export interface RecurrencePattern extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The day of the month on which the event occurs. Required if type is absoluteMonthly or absoluteYearly.
     */
    dayOfMonth?: number | null;
    /**
     * A collection of the days of the week on which the event occurs. The possible values are: sunday, monday, tuesday, wednesday, thursday, friday, saturday. If type is relativeMonthly or relativeYearly, and daysOfWeek specifies more than one day, the event falls on the first day that satisfies the pattern.  Required if type is weekly, relativeMonthly, or relativeYearly.
     */
    daysOfWeek?: DayOfWeek[] | null;
    /**
     * The first day of the week. The possible values are: sunday, monday, tuesday, wednesday, thursday, friday, saturday. Default is sunday. Required if type is weekly.
     */
    firstDayOfWeek?: DayOfWeek | null;
    /**
     * Specifies on which instance of the allowed days specified in daysOfWeek the event occurs, counted from the first instance in the month. The possible values are: first, second, third, fourth, last. Default is first. Optional and used if type is relativeMonthly or relativeYearly.
     */
    index?: WeekIndex | null;
    /**
     * The number of units between occurrences, where units can be in days, weeks, months, or years, depending on the type. Required.
     */
    interval?: number | null;
    /**
     * The month in which the event occurs.  This is a number from 1 to 12.
     */
    month?: number | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * The recurrence pattern type: daily, weekly, absoluteMonthly, relativeMonthly, absoluteYearly, relativeYearly. Required. For more information, see values of type property.
     */
    type?: RecurrencePatternType | null;
}
export type RecurrencePatternType = (typeof RecurrencePatternTypeObject)[keyof typeof RecurrencePatternTypeObject];
export interface RecurrenceRange extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The date to stop applying the recurrence pattern. Depending on the recurrence pattern of the event, the last occurrence of the meeting may not be this date. Required if type is endDate.
     */
    endDate?: DateOnly | null;
    /**
     * The number of times to repeat the event. Required and must be positive if type is numbered.
     */
    numberOfOccurrences?: number | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
    /**
     * Time zone for the startDate and endDate properties. Optional. If not specified, the time zone of the event is used.
     */
    recurrenceTimeZone?: string | null;
    /**
     * The date to start applying the recurrence pattern. The first occurrence of the meeting may be this date or later, depending on the recurrence pattern of the event. Must be the same value as the start property of the recurring event. Required.
     */
    startDate?: DateOnly | null;
    /**
     * The recurrence range. The possible values are: endDate, noEnd, numbered. Required.
     */
    type?: RecurrenceRangeType | null;
}
export type RecurrenceRangeType = (typeof RecurrenceRangeTypeObject)[keyof typeof RecurrenceRangeTypeObject];
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAttachmentBase(writer: SerializationWriter, attachmentBase: Partial<AttachmentBase> | undefined | null = {}) : void {
    if (attachmentBase) {
        serializeEntity(writer, attachmentBase)
        writer.writeStringValue("contentType", attachmentBase.contentType);
        writer.writeDateValue("lastModifiedDateTime", attachmentBase.lastModifiedDateTime);
        writer.writeStringValue("name", attachmentBase.name);
        writer.writeNumberValue("size", attachmentBase.size);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAttachmentSession(writer: SerializationWriter, attachmentSession: Partial<AttachmentSession> | undefined | null = {}) : void {
    if (attachmentSession) {
        serializeEntity(writer, attachmentSession)
        writer.writeObjectValue("content", attachmentSession.content);
        writer.writeDateValue("expirationDateTime", attachmentSession.expirationDateTime);
        writer.writeCollectionOfPrimitiveValues<string>("nextExpectedRanges", attachmentSession.nextExpectedRanges);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeBaseCollectionPaginationCountResponse(writer: SerializationWriter, baseCollectionPaginationCountResponse: Partial<BaseCollectionPaginationCountResponse> | undefined | null = {}) : void {
    if (baseCollectionPaginationCountResponse) {
        writer.writeNumberValue("@odata.count", baseCollectionPaginationCountResponse.odataCount);
        writer.writeStringValue("@odata.nextLink", baseCollectionPaginationCountResponse.odataNextLink);
        writer.writeAdditionalData(baseCollectionPaginationCountResponse.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeChecklistItem(writer: SerializationWriter, checklistItem: Partial<ChecklistItem> | undefined | null = {}) : void {
    if (checklistItem) {
        serializeEntity(writer, checklistItem)
        writer.writeDateValue("checkedDateTime", checklistItem.checkedDateTime);
        writer.writeDateValue("createdDateTime", checklistItem.createdDateTime);
        writer.writeStringValue("displayName", checklistItem.displayName);
        writer.writeBooleanValue("isChecked", checklistItem.isChecked);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDateTimeTimeZone(writer: SerializationWriter, dateTimeTimeZone: Partial<DateTimeTimeZone> | undefined | null = {}) : void {
    if (dateTimeTimeZone) {
        writer.writeStringValue("dateTime", dateTimeTimeZone.dateTime);
        writer.writeStringValue("@odata.type", dateTimeTimeZone.odataType);
        writer.writeStringValue("timeZone", dateTimeTimeZone.timeZone);
        writer.writeAdditionalData(dateTimeTimeZone.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeEntity(writer: SerializationWriter, entity: Partial<Entity> | undefined | null = {}) : void {
    if (entity) {
        writer.writeStringValue("id", entity.id);
        writer.writeStringValue("@odata.type", entity.odataType);
        writer.writeAdditionalData(entity.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeExtension(writer: SerializationWriter, extension: Partial<Extension> | undefined | null = {}) : void {
    if (extension) {
        serializeEntity(writer, extension)
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeItemBody(writer: SerializationWriter, itemBody: Partial<ItemBody> | undefined | null = {}) : void {
    if (itemBody) {
        writer.writeStringValue("content", itemBody.content);
        writer.writeEnumValue<BodyType>("contentType", itemBody.contentType);
        writer.writeStringValue("@odata.type", itemBody.odataType);
        writer.writeAdditionalData(itemBody.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeLinkedResource(writer: SerializationWriter, linkedResource: Partial<LinkedResource> | undefined | null = {}) : void {
    if (linkedResource) {
        serializeEntity(writer, linkedResource)
        writer.writeStringValue("applicationName", linkedResource.applicationName);
        writer.writeStringValue("displayName", linkedResource.displayName);
        writer.writeStringValue("externalId", linkedResource.externalId);
        writer.writeStringValue("webUrl", linkedResource.webUrl);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeOpenTypeExtension(writer: SerializationWriter, openTypeExtension: Partial<OpenTypeExtension> | undefined | null = {}) : void {
    if (openTypeExtension) {
        serializeExtension(writer, openTypeExtension)
        writer.writeStringValue("extensionName", openTypeExtension.extensionName);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializePatternedRecurrence(writer: SerializationWriter, patternedRecurrence: Partial<PatternedRecurrence> | undefined | null = {}) : void {
    if (patternedRecurrence) {
        writer.writeStringValue("@odata.type", patternedRecurrence.odataType);
        writer.writeObjectValue<RecurrencePattern>("pattern", patternedRecurrence.pattern, serializeRecurrencePattern);
        writer.writeObjectValue<RecurrenceRange>("range", patternedRecurrence.range, serializeRecurrenceRange);
        writer.writeAdditionalData(patternedRecurrence.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRecurrencePattern(writer: SerializationWriter, recurrencePattern: Partial<RecurrencePattern> | undefined | null = {}) : void {
    if (recurrencePattern) {
        writer.writeNumberValue("dayOfMonth", recurrencePattern.dayOfMonth);
        if(recurrencePattern.daysOfWeek)
        writer.writeEnumValue<DayOfWeek>("daysOfWeek", ...recurrencePattern.daysOfWeek);
        writer.writeEnumValue<DayOfWeek>("firstDayOfWeek", recurrencePattern.firstDayOfWeek);
        writer.writeEnumValue<WeekIndex>("index", recurrencePattern.index);
        writer.writeNumberValue("interval", recurrencePattern.interval);
        writer.writeNumberValue("month", recurrencePattern.month);
        writer.writeStringValue("@odata.type", recurrencePattern.odataType);
        writer.writeEnumValue<RecurrencePatternType>("type", recurrencePattern.type);
        writer.writeAdditionalData(recurrencePattern.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRecurrenceRange(writer: SerializationWriter, recurrenceRange: Partial<RecurrenceRange> | undefined | null = {}) : void {
    if (recurrenceRange) {
        writer.writeDateOnlyValue("endDate", recurrenceRange.endDate);
        writer.writeNumberValue("numberOfOccurrences", recurrenceRange.numberOfOccurrences);
        writer.writeStringValue("@odata.type", recurrenceRange.odataType);
        writer.writeStringValue("recurrenceTimeZone", recurrenceRange.recurrenceTimeZone);
        writer.writeDateOnlyValue("startDate", recurrenceRange.startDate);
        writer.writeEnumValue<RecurrenceRangeType>("type", recurrenceRange.type);
        writer.writeAdditionalData(recurrenceRange.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTaskFileAttachment(writer: SerializationWriter, taskFileAttachment: Partial<TaskFileAttachment> | undefined | null = {}) : void {
    if (taskFileAttachment) {
        serializeAttachmentBase(writer, taskFileAttachment)
        writer.writeObjectValue("contentBytes", taskFileAttachment.contentBytes);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTodoTask(writer: SerializationWriter, todoTask: Partial<TodoTask> | undefined | null = {}) : void {
    if (todoTask) {
        serializeEntity(writer, todoTask)
        writer.writeCollectionOfObjectValues<AttachmentBase>("attachments", todoTask.attachments, serializeAttachmentBase);
        writer.writeCollectionOfObjectValues<AttachmentSession>("attachmentSessions", todoTask.attachmentSessions, serializeAttachmentSession);
        writer.writeObjectValue<ItemBody>("body", todoTask.body, serializeItemBody);
        writer.writeDateValue("bodyLastModifiedDateTime", todoTask.bodyLastModifiedDateTime);
        writer.writeCollectionOfPrimitiveValues<string>("categories", todoTask.categories);
        writer.writeCollectionOfObjectValues<ChecklistItem>("checklistItems", todoTask.checklistItems, serializeChecklistItem);
        writer.writeObjectValue<DateTimeTimeZone>("completedDateTime", todoTask.completedDateTime, serializeDateTimeTimeZone);
        writer.writeDateValue("createdDateTime", todoTask.createdDateTime);
        writer.writeObjectValue<DateTimeTimeZone>("dueDateTime", todoTask.dueDateTime, serializeDateTimeTimeZone);
        writer.writeCollectionOfObjectValues<Extension>("extensions", todoTask.extensions, serializeExtension);
        writer.writeBooleanValue("hasAttachments", todoTask.hasAttachments);
        writer.writeEnumValue<Importance>("importance", todoTask.importance);
        writer.writeBooleanValue("isReminderOn", todoTask.isReminderOn);
        writer.writeDateValue("lastModifiedDateTime", todoTask.lastModifiedDateTime);
        writer.writeCollectionOfObjectValues<LinkedResource>("linkedResources", todoTask.linkedResources, serializeLinkedResource);
        writer.writeObjectValue<PatternedRecurrence>("recurrence", todoTask.recurrence, serializePatternedRecurrence);
        writer.writeObjectValue<DateTimeTimeZone>("reminderDateTime", todoTask.reminderDateTime, serializeDateTimeTimeZone);
        writer.writeObjectValue<DateTimeTimeZone>("startDateTime", todoTask.startDateTime, serializeDateTimeTimeZone);
        writer.writeEnumValue<TaskStatus>("status", todoTask.status);
        writer.writeStringValue("title", todoTask.title);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTodoTaskCollectionResponse(writer: SerializationWriter, todoTaskCollectionResponse: Partial<TodoTaskCollectionResponse> | undefined | null = {}) : void {
    if (todoTaskCollectionResponse) {
        serializeBaseCollectionPaginationCountResponse(writer, todoTaskCollectionResponse)
        writer.writeCollectionOfObjectValues<TodoTask>("value", todoTaskCollectionResponse.value, serializeTodoTask);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTodoTaskList(writer: SerializationWriter, todoTaskList: Partial<TodoTaskList> | undefined | null = {}) : void {
    if (todoTaskList) {
        serializeEntity(writer, todoTaskList)
        writer.writeStringValue("displayName", todoTaskList.displayName);
        writer.writeCollectionOfObjectValues<Extension>("extensions", todoTaskList.extensions, serializeExtension);
        writer.writeBooleanValue("isOwner", todoTaskList.isOwner);
        writer.writeBooleanValue("isShared", todoTaskList.isShared);
        writer.writeCollectionOfObjectValues<TodoTask>("tasks", todoTaskList.tasks, serializeTodoTask);
        writer.writeEnumValue<WellknownListName>("wellknownListName", todoTaskList.wellknownListName);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTodoTaskListCollectionResponse(writer: SerializationWriter, todoTaskListCollectionResponse: Partial<TodoTaskListCollectionResponse> | undefined | null = {}) : void {
    if (todoTaskListCollectionResponse) {
        serializeBaseCollectionPaginationCountResponse(writer, todoTaskListCollectionResponse)
        writer.writeCollectionOfObjectValues<TodoTaskList>("value", todoTaskListCollectionResponse.value, serializeTodoTaskList);
    }
}
export interface TaskFileAttachment extends AttachmentBase, Parsable {
    /**
     * The base64-encoded contents of the file.
     */
    contentBytes?: String | null;
}
export type TaskStatus = (typeof TaskStatusObject)[keyof typeof TaskStatusObject];
export interface TodoTask extends Entity, Parsable {
    /**
     * A collection of file attachments for the task.
     */
    attachments?: AttachmentBase[] | null;
    /**
     * The attachmentSessions property
     */
    attachmentSessions?: AttachmentSession[] | null;
    /**
     * The task body that typically contains information about the task.
     */
    body?: ItemBody | null;
    /**
     * The date and time when the task body was last modified. By default, it is in UTC. You can provide a custom time zone in the request header. The property value uses ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2020 would look like this: '2020-01-01T00:00:00Z'.
     */
    bodyLastModifiedDateTime?: Date | null;
    /**
     * The categories associated with the task. Each category corresponds to the displayName property of an outlookCategory that the user has defined.
     */
    categories?: string[] | null;
    /**
     * A collection of checklistItems linked to a task.
     */
    checklistItems?: ChecklistItem[] | null;
    /**
     * The date and time in the specified time zone that the task was finished.
     */
    completedDateTime?: DateTimeTimeZone | null;
    /**
     * The date and time when the task was created. By default, it is in UTC. You can provide a custom time zone in the request header. The property value uses ISO 8601 format. For example, midnight UTC on Jan 1, 2020 would look like this: '2020-01-01T00:00:00Z'.
     */
    createdDateTime?: Date | null;
    /**
     * The date and time in the specified time zone that the task is to be finished.
     */
    dueDateTime?: DateTimeTimeZone | null;
    /**
     * The collection of open extensions defined for the task. Nullable.
     */
    extensions?: Extension[] | null;
    /**
     * Indicates whether the task has attachments.
     */
    hasAttachments?: boolean | null;
    /**
     * The importance property
     */
    importance?: Importance | null;
    /**
     * Set to true if an alert is set to remind the user of the task.
     */
    isReminderOn?: boolean | null;
    /**
     * The date and time when the task was last modified. By default, it is in UTC. You can provide a custom time zone in the request header. The property value uses ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2020 would look like this: '2020-01-01T00:00:00Z'.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * A collection of resources linked to the task.
     */
    linkedResources?: LinkedResource[] | null;
    /**
     * The recurrence pattern for the task.
     */
    recurrence?: PatternedRecurrence | null;
    /**
     * The date and time in the specified time zone for a reminder alert of the task to occur.
     */
    reminderDateTime?: DateTimeTimeZone | null;
    /**
     * The date and time in the specified time zone at which the task is scheduled to start.
     */
    startDateTime?: DateTimeTimeZone | null;
    /**
     * The status property
     */
    status?: TaskStatus | null;
    /**
     * A brief description of the task.
     */
    title?: string | null;
}
export interface TodoTaskCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: TodoTask[] | null;
}
export interface TodoTaskList extends Entity, Parsable {
    /**
     * The name of the task list.
     */
    displayName?: string | null;
    /**
     * The collection of open extensions defined for the task list. Nullable.
     */
    extensions?: Extension[] | null;
    /**
     * True if the user is owner of the given task list.
     */
    isOwner?: boolean | null;
    /**
     * True if the task list is shared with other users
     */
    isShared?: boolean | null;
    /**
     * The tasks in this task list. Read-only. Nullable.
     */
    tasks?: TodoTask[] | null;
    /**
     * The wellknownListName property
     */
    wellknownListName?: WellknownListName | null;
}
export interface TodoTaskListCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: TodoTaskList[] | null;
}
export type WeekIndex = (typeof WeekIndexObject)[keyof typeof WeekIndexObject];
export type WellknownListName = (typeof WellknownListNameObject)[keyof typeof WellknownListNameObject];
export const BodyTypeObject = {
    Text: "text",
    Html: "html",
} as const;
export const DayOfWeekObject = {
    Sunday: "sunday",
    Monday: "monday",
    Tuesday: "tuesday",
    Wednesday: "wednesday",
    Thursday: "thursday",
    Friday: "friday",
    Saturday: "saturday",
} as const;
export const ImportanceObject = {
    Low: "low",
    Normal: "normal",
    High: "high",
} as const;
export const RecurrencePatternTypeObject = {
    Daily: "daily",
    Weekly: "weekly",
    AbsoluteMonthly: "absoluteMonthly",
    RelativeMonthly: "relativeMonthly",
    AbsoluteYearly: "absoluteYearly",
    RelativeYearly: "relativeYearly",
} as const;
export const RecurrenceRangeTypeObject = {
    EndDate: "endDate",
    NoEnd: "noEnd",
    Numbered: "numbered",
} as const;
export const TaskStatusObject = {
    NotStarted: "notStarted",
    InProgress: "inProgress",
    Completed: "completed",
    WaitingOnOthers: "waitingOnOthers",
    Deferred: "deferred",
} as const;
export const WeekIndexObject = {
    First: "first",
    Second: "second",
    Third: "third",
    Fourth: "fourth",
    Last: "last",
} as const;
export const WellknownListNameObject = {
    None: "none",
    DefaultList: "defaultList",
    FlaggedEmails: "flaggedEmails",
    UnknownFutureValue: "unknownFutureValue",
} as const;
/* tslint:enable */
/* eslint-enable */
